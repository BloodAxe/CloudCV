{"ts":1377511211939,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#include <node.h>\n#include <opencv2/opencv.hpp>\n#include <string>\n\nusing namespace v8;\n\n// This function returns a JavaScript number that is either 0 or 1.\nHandle<Value> buildInformation(const Arguments& args)\n{\n    // At the top of every function that uses anything about v8, include a\n    // definition like this. It ensures that any v8 handles you create in that\n    // function are properly cleaned up. If you see memory rising in your\n    // application, chances are that a scope isn't properly cleaned up.\n    HandleScope scope;\n\n    // When returning a value from a function, make sure to wrap it in\n    // scope.Close(). This ensures that the handle stays valid after the current\n    // scope (declared with the previous statement) is cleaned up.\n    return scope.Close\n    (\n        // Creating a new JavaScript integer is as simple as passing a C int\n        // (technically a int32_t) to this function.\n        String::New(cv::getBuildInformation().c_str())\n    );\n}\n\nvoid RegisterModule(Handle<Object> target)\n{\n    // target is the module object you see when require()ing the .node file.\n    target->Set(String::NewSymbol(\"buildInformation\"), FunctionTemplate::New(buildInformation)->GetFunction());\n}\n\nNODE_MODULE(cv, RegisterModule);"]],"start1":0,"start2":0,"length1":0,"length2":1248}]],"length":1248}
{"contributors":[],"silentsave":false,"ts":1377511243619,"patch":[[{"diffs":[[0,"ce v8;\n\n"],[1,"extern \"C\"\n{\n    \n"],[0,"// This "]],"start1":80,"start2":80,"length1":16,"length2":34},{"diffs":[[0,"Module);"],[1,"\n}"]],"start1":1258,"start2":1258,"length1":8,"length2":10}]],"length":1268,"saved":false}
{"contributors":[],"silentsave":false,"ts":1377583658708,"patch":[[{"diffs":[[0,"/ At the"],[1,"p"],[0," top of "]],"start1":235,"start2":235,"length1":16,"length2":17}]],"length":1269,"saved":false}
